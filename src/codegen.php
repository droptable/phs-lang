<?php

namespace phs;

use phs\ast\FnDecl;
use phs\ast\FnExpr;
use phs\ast\CtorDecl;
use phs\ast\DtorDecl;
use phs\ast\Name;
use phs\ast\Ident;
use phs\ast\TypeId;

/** code generator */
class CodeGenerator extends AutoVisitor
{
  // @var Session
  private $sess;
  
  // @var resource  file-handle
  private $fhnd;
  
  // @var string
  private $buff;
  
  // @var int  tab-size
  private $tabs;
  
  // @var array
  private $mods;
  
  // @var int
  private $imod;
  
  // @var int
  private $nest;
  
  // @var int  used to generate temporary variables
  private static $temp = 0;
  
  /**
   * constructor
   *
   * @param Session $sess
   */
  public function __construct(Session $sess)
  {
    parent::__construct();
    $this->sess = $sess;
  }
  
  /**
   * process a source
   *
   * @param  Source $src
   */
  public function process(Source $src)
  {
    if ($src->php)
      file_put_contents($src->get_dest(), $src->get_data());
    else {
      $this->buff = '';
      $this->tabs = 0;
      $this->nest = 0;
      $this->fhnd = fopen($src->get_dest(), 'w+');
            
      // module-generation specific
      $this->mods = [];
      $this->imod = 0;
      
      $this->emitln('<?php');
      $this->emitln('/* this file was generated by PHS */');
      
      $this->visit($src->unit);
      $this->flush();
      
      fclose($this->fhnd);
    }   
  }
  
  /**
   * flushes the buffer to the output stream
   *
   */
  private function flush()
  {
    fwrite($this->fhnd, $this->buff);
    $this->buff = '';
  }
  
  /* ------------------------------------ */
  
  /**
   * emit data to the buffer
   *
   */
  public function emit()
  {
    for ($i = 0, $l = func_num_args(); $i < $l; ++$i)
      $this->buff .= $this->filter(func_get_arg($i));
  }
  
  /**
   * emit data + a new line to the buffer
   *
   */
  public function emitln()
  {
    for ($i = 0, $l = func_num_args(); $i < $l; ++$i)
      $this->buff .= $this->filter(func_get_arg($i));
    
    $this->buff .= "\n";
    $this->buff .= str_repeat('  ', $this->tabs);
  }
  
  /**
   * emits a list of values as quoted strings
   *
   */
  public function emitqs()
  {
    for ($i = 0, $l = func_num_args(); $i < $l; ++$i)
      $this->buff .= $this->quote(func_get_arg($i));
  }
  
  /**
   * quotes a string-value
   *
   * @param  mixed $val
   * @return string
   */
  public function quote($val)
  {
    $val = $this->filter($val);
    $str = '"';
    $esc = false;
    
    for ($i = 0, $l = strlen($val); $i < $l; ++$i) {
      $cur = $val[$i];
      
      if ($cur === '\\')
        $esc = !$esc;
      elseif ($cur === '"') {
        if ($esc) 
          $esc = false;
        else
          $str .= '\\';
      } else {
        switch ($cur) {
          case "\n": $cur = '\\n'; break; 
          case "\r": $cur = '\\r'; break;          
          case "\t": $cur = '\\t'; break;         
          case "\f": $cur = '\\f'; break;          
          case "\v": $cur = '\\v'; break;          
          case "\e": $cur = '\\e'; break;
          case '\\': $cur = '\\\\'; break;
          case '"': $cur = "\\\""; break;
        }
      }
      
      $str .= $cur;
    }
    
    $str .= '"';
    return $str;
  }
  
  /**
   * gets called for all values passed to emit() or emitln()
   *
   * @param  mixed $val
   * @return string
   */
  public function filter($val)
  {
    return (string) $val;
  }
  
  /**
   * increment tab-count
   *
   */
  public function indent()
  {
    $this->buff = rtrim($this->buff, "\n ");
    $this->tabs++;
    $this->emitln();
  }
  
  /**
   * decrement tab-count
   * 
   */
  public function dedent()
  {
    if ($this->tabs - 1 >= 0) {
      $this->buff = rtrim($this->buff, "\n ");
      $this->tabs--;
      $this->emitln();
    }
  }
  
  /* ------------------------------------ */
  
  /**
   * emits the start (header) of a namespace
   *
   * @param  ModuleScope $mod
   */
  public function emit_ns_beg(ModuleScope $mod = null)
  {
    $this->emit('namespace ');
    
    if ($mod !== null && $mod->id !== null) {
      $this->emit(path_to_ns($mod->path()));
      $this->emit(' ');
    }
    
    $this->emitln('{');
    $this->indent();
  }
  
  /**
   * emits the end (footer) of a namespace
   *
   */
  public function emit_ns_end()
  {
    $this->dedent();
    $this->emitln('}');
  }
  
  /* ------------------------------------ */
  
  /**
   * emits a function-declaration
   *
   * @param  Node $node
   */
  public function emit_fn_decl($node)
  {
    $fsym = $node->symbol;
    
    $this->emit('function ', $fsym->id);
    $this->emit_fn_params($node);
    $this->emit_fn_body($node);
  }
  
  /**
   * emits a function-expression
   *
   * @param  Node $node
   * @param  boolean  $decl  the function is actually a declaration
   */
  public function emit_fn_expr($node, $decl = false)
  {
    $fsym = $node->symbol;
    
    $this->emit('$', $fsym->id, ' = function');
    $this->emit_fn_params($node);
    $this->emit_fn_body($node, true, $decl);
  }
  
  /**
   * emits function-params
   *
   * @param  Node $node
   */
  public function emit_fn_params($node)
  {
    $fsym = $node->symbol;
    
    $this->emit('(');
          
    foreach ($fsym->params as $idx => $psym) {
      if ($idx > 0) $this->emit(', ');
      
      if ($psym->hint && !($psym->hint instanceof TypeId)) {
        $this->emit('\\', path_to_ns($psym->hint->symbol->path()));
        $this->emit(' ');
      }
      
      if ($psym->ref) $this->emit('&');
      if ($psym->rest) $this->emit('...');
      
      $this->emit('$', $psym->id);      
    }
      
    $this->emit(') ');
  }
  
  /**
   * emits function global-captures
   *
   * @param  Node $node
   */
  public function emit_fn_globals($node)
  {
    foreach ($node->scope->capt as $sym)
      if ($sym->scope->is_global())
        $this->emitln('global $', $sym->id, ';');
  }
  
  /**
   * emits function captures
   *
   * @param  Node $node
   */
  public function emit_fn_captures($node)
  {
    $capt = [];
    
    if ($node instanceof FnExpr || $node->nested)
      // capture self
      $capt[] = $node->symbol;
    
    foreach ($node->scope->capt as $csym)
      if (!$csym->scope->is_global())
        $capt[] = $csym;
    
    if (empty ($capt))
      return;
    
    $this->emit('use (');
      
    foreach ($capt as $idx => $csym) {
      if ($idx > 0) $this->emit(', ');
      $this->emit('&$', $csym->id);
    }
      
    $this->emit(') ');
  }
  
  /**
   * emits additional parameter type-checks
   *
   * @param  Node $node
   */
  public function emit_fn_checks($node)
  {
    static $ttos = [
      T_TINT => 'int',
      T_TFLOAT => 'float',
      T_TBOOL => 'bool',
      T_TSTRING => 'string',
    ];
    
    $fsym = $node->symbol;
    
    foreach ($fsym->params as $idx => $psym)
      if ($psym->hint && $psym->hint instanceof TypeId) {
        $id = $psym->id;
        $nr = '';
        $fn = $ttos[$psym->hint->type];
        
        if ($psym->rest) {
          $nr = '_T' . (self::$temp++);
          $id = '_T' . (self::$temp++);
          $this->emit('foreach ($', $psym->id, ' as $', $nr);
          $this->emitln(' => $', $id, ')');
          $this->indent();
        }
        
        if ($psym->ref) {
          $this->emitln('if (!is_', $fn, '($', $id, '))');
          $this->indent();
          $this->emit('throw new \\InvalidArgumentException(', "'");
          $this->emit($fsym->rid, '(): parameter #', $idx + 1, ' ');
          $this->emit('(`', $psym->rid, '`) - expected argument');
          
          // well, now we have argumentS
          if ($psym->rest) $this->emit('s');
          
          $this->emit(' of type ', $fn);
          
          // mark the argument as tuple
          if ($psym->rest) 
            $this->emit(' [...]');
          
          $this->emit(", ' . gettype($", $id, ") . ' given");
          
          // show offset of invalid tuple-value
          if ($psym->rest) 
            $this->emit(" at position ' . ($", $nr, ' + ', $idx + 1, ')');
          else
            $this->emit("'");
          
          $this->emitln(');');
          $this->dedent();
        } else
          $this->emitln('$', $id, ' = (', $fn, ') $', $id, ';');
          
        if ($psym->rest) {
          self::$temp -= 2;
          $this->dedent();
        } 
      }
  }
  
  /**
   * emits a function-body
   *
   * @param  Node $node
   * @param  boolean $expr  this body is part of a function-expression
   * @param  boolean $term  the function needs a terminator (semicolon)
   */
  public function emit_fn_body($node, $expr = false, $term = false)
  {
    if ($expr === true)
      $this->emit_fn_captures($node);
    
    $this->emitln('{');
    $this->indent();
    
    $this->emit_fn_globals($node);
    $this->emit_fn_checks($node);
    
    // visit block-body directly
    $this->nest++;
    $this->visit($node->body->body);
    $this->nest--;
    
    $this->dedent();
    $this->emit('}');
    
    if ($term === true)
      $this->emit(';');
    
    $this->emitln();
  }
  
  /* ------------------------------------ */
  
  public function visit_fn_args($args) {}
  public function visit_fn_params($params) {}
  
  /* ------------------------------------ */
  
  public function visit_unit($node) 
  {
    $this->emit_ns_beg();
    $this->visit($node->body);
    $this->emit_ns_end();
  }
  
  public function visit_module($node) 
  {
    $pmod = null;
    
    // close previous module
    if ($this->imod > 0)
      $pmod = array_pop($this->mods);
    
    $this->emit_ns_end();
    
    $this->imod++;
    
    $cmod = $node->scope;
    array_push($this->mods, $cmod);
    
    $this->emit_ns_beg($cmod);
    $this->visit($node->body);
    $this->emit_ns_end();
    
    $this->imod--;
    
    // re-open previous module
    if ($pmod) {
      array_push($this->mods, $pmod);
      $this->emit_ns_beg($pmod);
    } else
      $this->emit_ns_beg();
  }
  
  public function visit_content($node) 
  {
    $this->visit($node->body);  
  } 
  
  public function visit_block($node) 
  {
    $this->nest++;
    
    $this->emitln('{');
    $this->indent();
    
    $this->visit($node->body);
    
    // unset vars  
    // 
    // note: PHP awesomely handles captured variables as one might expect.
    // there is no need to write workarounds for code like:
    // 
    // $foo = 1;
    // $bar = function() use (&$foo) { echo $foo; };
    // unset ($foo); // <- no problem, just decreases its refcount :-)
    // $bar(); // 1
    //     
    // therefore block-scope can be safely simulated with unset()
    $scope = $node->scope;
    if ($scope->count()) {
      $this->emit('unset (');
        
      foreach ($scope->iter() as $idx => $sym) {
        if ($idx > 0) $this->emit(', ');
        $this->emit('$', $sym->id);
      }
      
      $this->emit(')');
      $this->emitln(';');
    }
    
    $this->dedent();
    $this->emitln('}');
    
    $this->nest--;
  }
  
  public function visit_enum_decl($node) 
  {
    // TODO: implement enums
  }
  
  public function visit_class_decl($n) {}
  public function visit_nested_mods($n) {}
  public function visit_ctor_decl($n) {}
  public function visit_dtor_decl($n) {}
  public function visit_getter_decl($n) {}
  public function visit_setter_decl($n) {}
  public function visit_trait_decl($n) {}
  public function visit_iface_decl($n) {}
    
  public function visit_fn_decl($node) 
  {
    if ($node->nested)
      $this->emit_fn_expr($node, true);
    else
      $this->emit_fn_decl($node);
  }
  
  public function visit_var_decl($node) 
  {
    foreach ($node->vars as $var) {
      if (!$var->init) 
        // no declaration needed
        continue;
      
      $this->emit('$', $var->symbol->id, ' = ');
      $this->visit($var->init);
      $this->emitln(';');
    }
  }
  
  public function visit_use_decl($node) 
  {
    // noop  
  }
  
  public function visit_require_decl($node) 
  {
    $this->emit('require_once ');
    $this->emitqs($node->path); 
    $this->emitln(';');
  }
  
  public function visit_label_decl($node) 
  {
    $this->emitln(ident_to_str($node->id), ':');
    $this->visit($node->stmt);
  }
  
  public function visit_do_stmt($node) 
  {
    $this->emit('do ');
    $this->visit($node->stmt);
    $this->buff = rtrim($this->buff, "\n ");
    $this->emit(' while (');
    $this->visit($node->test);
    $this->emitln(');');  
  }
  
  public function visit_if_stmt($node) 
  {
    $this->emit('if (');
    $this->visit($node->test);
    $this->emit(') ');
    $this->visit($node->stmt);
    
    if ($node->elsifs) {
      foreach ($node->elsifs as $elsif) {
        $this->buff = rtrim($this->buff, "\n ");
        $this->emit(' elseif (');
        $this->visit($elsif->test);
        $this->emit(') ');
        $this->visit($elsif->stmt);   
      } 
    } 
    
    if ($node->els) {
      $this->buff = rtrim($this->buff, "\n ");
      $this->emit(' else ');
      $this->visit($node->els->stmt);
    }
  }
  
  public function visit_for_stmt($node) 
  {
    $this->emit('for (');
      
    if ($node->init) {
      $this->visit($node->init);
      $this->buff = rtrim($this->buff, "\n ");
      $this->emit(' ');
    } else
      $this->emit('; ');
    
    if ($node->test) {
      $this->visit($node->test);
      $this->buff = rtrim($this->buff, "\n ");
      $this->emit(' ');
    } else
      $this->emit('; ');
    
    $this->visit($node->each);
    $this->emit(') ');
    $this->visit($node->stmt);  
    
    // TODO: unset vars
  }
  
  public function visit_for_in_stmt($node) 
  {
    $this->emit('foreach (');
    $this->visit($node->rhs);
    $this->emit(' as ');
    
    $key = $node->lhs->key;
    $arg = $node->lhs->arg;
    
    if ($key !== null)
      $this->emit('$', $key->symbol->id, ' => ');  
    
    $this->emit('$', $arg->symbol->id);
    $this->emit(') ');
    $this->visit($node->stmt);
    
    $this->emit('unset (');
    
    if ($key != null)
      $this->emit('$', $key->symbol->id, ', ');
    
    $this->emit('$', $arg->symbol->id);
    $this->emitln(');');
  }
  
  public function visit_try_stmt($n) {}
  public function visit_php_stmt($n) {}
  public function visit_goto_stmt($n) {}
  public function visit_test_stmt($n) {}
  public function visit_break_stmt($n) {}
  public function visit_continue_stmt($n) {}
  public function visit_print_stmt($n) {}
  public function visit_throw_stmt($n) {}
  public function visit_while_stmt($n) {}
  public function visit_assert_stmt($n) {}
  public function visit_switch_stmt($n) {}
  public function visit_return_stmt($n) {}
  public function visit_expr_stmt($n) {}
  public function visit_paren_expr($n) {}
  public function visit_tuple_expr($n) {}
  
  public function visit_fn_expr($node) 
  {
    $this->emit_fn_expr($node);
  }
  
  public function visit_bin_expr($n) {}
  public function visit_check_expr($n) {}
  public function visit_cast_expr($n) {}
  public function visit_update_expr($n) {}
  public function visit_assign_expr($n) {}
  public function visit_member_expr($n) {}
  public function visit_offset_expr($n) {}
  public function visit_cond_expr($n) {}
  public function visit_call_expr($n) {}
  public function visit_yield_expr($n) {}
  public function visit_unary_expr($n) {}
  public function visit_new_expr($n) {}
  public function visit_del_expr($n) {}
  public function visit_lnum_lit($n) {}
  public function visit_dnum_lit($n) {}
  public function visit_snum_lit($n) {}
  public function visit_regexp_lit($n) {}
  public function visit_arr_gen($n) {}
  public function visit_arr_lit($n) {}
  public function visit_obj_lit($n) {}
  public function visit_name($n) {}
  public function visit_ident($n) {}
  public function visit_this_expr($n) {}
  public function visit_super_expr($n) {}
  public function visit_self_expr($n) {}
  public function visit_null_lit($n) {}
  public function visit_true_lit($n) {}
  public function visit_false_lit($n) {}
  public function visit_str_lit($n) {}
  public function visit_kstr_lit($n) {}
  public function visit_type_id($n) {}
  public function visit_engine_const($n) {}
}
