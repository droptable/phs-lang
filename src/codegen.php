<?php

namespace phs;

use phs\ast\FnDecl;
use phs\ast\FnExpr;
use phs\ast\CtorDecl;
use phs\ast\DtorDecl;
use phs\ast\Name;
use phs\ast\Ident;
use phs\ast\TypeId;
use phs\ast\CallExpr;
use phs\ast\VarDecl;
use phs\ast\StrLit;
use phs\ast\NewExpr;
use phs\ast\AssignExpr;
use phs\ast\ObjLit;
use phs\ast\ObjKey;

/** code generator */
class CodeGenerator extends AutoVisitor
{
  // @var Session
  private $sess;
  
  // @var resource  file-handle
  private $fhnd;
  
  // @var string
  private $buff;
  
  // @var int  tab-size
  private $tabs;
  
  // @var array
  private $mods;
  
  // @var int
  private $imod;
  
  // @var int
  private $nest;
  
  // @var bool  ignore values
  private $ignv;
  
  // @var bool  hoist strings
  private $hstr;
  
  // @var array  hoisted strings
  private $strs;
  
  // @var int  used to generate temporary variables
  private static $temp = 0;
  
  /**
   * constructor
   *
   * @param Session $sess
   */
  public function __construct(Session $sess)
  {
    parent::__construct();
    $this->sess = $sess;
  }
  
  /**
   * process a source
   *
   * @param  Source $src
   */
  public function process(Source $src)
  {
    if ($src->php)
      file_put_contents($src->get_dest(), $src->get_data());
    else {
      $this->buff = '';
      $this->tabs = 0;
      $this->nest = 0;
      $this->hstr = true;
      $this->strs = [];
      $this->ignv = false;
      $this->fhnd = fopen($src->get_dest(), 'w+');
            
      // module-generation specific
      $this->mods = [];
      $this->imod = 0;
      
      $this->emitln('<?php');
      $this->emitln('/* this file was generated by PHS */');
      
      $this->visit($src->unit);
      $this->flush();
      
      fclose($this->fhnd);
    }   
  }
  
  /**
   * flushes the buffer to the output stream
   *
   */
  private function flush()
  {
    fwrite($this->fhnd, $this->buff);
    $this->buff = '';
  }
  
  /* ------------------------------------ */
  
  /**
   * emit data to the buffer
   *
   */
  public function emit()
  {
    for ($i = 0, $l = func_num_args(); $i < $l; ++$i)
      $this->buff .= $this->filter(func_get_arg($i));
  }
  
  /**
   * emit data + a new line to the buffer
   *
   */
  public function emitln()
  {
    for ($i = 0, $l = func_num_args(); $i < $l; ++$i)
      $this->buff .= $this->filter(func_get_arg($i));
    
    $this->buff .= "\n";
    $this->buff .= str_repeat('  ', $this->tabs);
  }
  
  /**
   * emits a list of values as quoted strings
   *
   */
  public function emitqs()
  {
    for ($i = 0, $l = func_num_args(); $i < $l; ++$i)
      $this->buff .= $this->quote(func_get_arg($i));
  }
  
  /**
   * quotes a string-value
   *
   * @param  mixed $val
   * @return string
   */
  public function quote($val)
  {
    $val = $this->filter($val);
    return '"' . $this->format_str($val) . '"';
  }
  
  /**
   * gets called for all values passed to emit() or emitln()
   *
   * @param  mixed $val
   * @return string
   */
  public function filter($val)
  {
    return (string) $val;
  }
  
  /**
   * increment tab-count
   *
   */
  public function indent()
  {
    $this->buff = rtrim($this->buff, "\n ");
    $this->tabs++;
    $this->emitln();
  }
  
  /**
   * decrement tab-count
   * 
   */
  public function dedent()
  {
    if ($this->tabs - 1 >= 0) {
      $this->buff = rtrim($this->buff, "\n ");
      $this->tabs--;
      $this->emitln();
    }
  }
  
  /* ------------------------------------ */
  
  /**
   * collects chained callees e.g.: foo()()
   *
   * @param  Node $node
   * @return array
   */
  public function collect_callees($node)
  {
    $list = [];
    $call = $node;
    
    for (;;) {
      $list[] = $call;
      
      if ($call->callee instanceof CallExpr)
        $call = $call->callee;
      else
        break;
    }
    
    return $list;
  }
  
  /**
   * formats a value to a soon-to-be-quoted string
   *
   * @param  string $val
   * @param  string $dlm
   * @return string
   */
  public function format_str($val, $dlm = '"')
  {
    $esc = false;
    $str = '';
    
    for ($i = 0, $l = strlen($val); $i < $l; ++$i) {
      $cur = $val[$i];
      
      if ($cur === '\\')
        $esc = !$esc;
      elseif ($cur === '"') {
        if ($esc) 
          $esc = false;
        else
          $str .= '\\';
      } else {
        switch ($cur) {
          case "\n": $cur = '\\n'; break; 
          case "\r": $cur = '\\r'; break;          
          case "\t": $cur = '\\t'; break;         
          case "\f": $cur = '\\f'; break;          
          case "\v": $cur = '\\v'; break;          
          case "\e": $cur = '\\e'; break;
          case '\\': $cur = '\\\\'; break;
          case $dlm: $cur = "\\$dlm"; break;
        }
      }
      
      $str .= $cur;
    }
    
    return $str;
  }
  
  /* ------------------------------------ */
  
  /**
   * emits a operator
   *
   * @param  Token  $op 
   * @param  boolean $bin
   */
  public function emit_op($op, $bin = false)
  {
    $val = $op->value;
    
    switch ($op->type) {
      case T_ACONCAT:
        $val = '.=';
        break;
      case T_CONCAT:
        if ($bin === true)
          $val = '.';
        break;
    }
    
    $this->emit($val);
  }
  
  /**
   * emits a string literal
   *
   * @param  StrLit $node
   * @param  bool   $cat   concatenate strings if necessary
   */
  public function emit_str($node, $cat = true)
  {
    assert($node instanceof StrLit);
    
    $idx = 1;
    
    if ($node->data === '' && $node->parts)
      // first slice is empty: skip it
      $idx = 0;
    else    
      // emit first slice
      $this->emit_str_fmt($node->data);
    
    if ($node->parts)
      foreach ($node->parts as $part) {
        if ($idx > 0) 
          if ($cat === true)
            $this->emit(' . ');
          else
            $this->emit(', ');
        
        if ($part instanceof StrLit)
          $this->emit_str_fmt($part->data);
        else {
          if ($cat === true) {
            $this->emit('(');
            $this->visit($part);
            $this->emit(')');
          } else
            $this->visit($part);
        }
        
        $idx++;
      }
  }
  
  /**
   * emits a formated string (with quotes and stuff)
   *
   * @param  string $val
   */
  public function emit_str_fmt($val)
  {
    // scan string to decide which delimiter must be used
    $dlm = "'";
    $len = strlen($val);
    
    if (strpos($val, "\n") !== false ||
        strpos($val, "\r") !== false ||
        strpos($val, "\t") !== false ||
        strpos($val, "\f") !== false ||
        strpos($val, "\v") !== false ||
        strpos($val, "\e") !== false)
      $dlm = '"';
    
    $str = '';
    for ($idx = 0; $idx < $len; ++$idx) {
      $cur = $val[$idx];
      
      switch ($cur) {
        case "\n": $cur = '\\n'; break;
        case "\r": $cur = '\\r'; break;
        case "\t": $cur = '\\t'; break;
        case "\f": $cur = '\\f'; break;
        case "\v": $cur = '\\v'; break;
        case "\e": $cur = '\\e'; break;
        case '\\': $cur = '\\\\'; break;
        case $dlm: 
          $cur = '\\';
          $cur .= $dlm;
          break;
      }
      
      $str .= $cur;
    }
    
    // finally
    $this->emit($dlm, $str, $dlm);
  }
  
  /* ------------------------------------ */
  
  /**
   * emits a value
   *
   * @param  Value $value
   * @return boolean
   */
  public function emit_value(Value $value = null)
  {
    if ($this->ignv || !$value || $value->is_unkn()) 
      return false;
     
    switch ($value->kind) {
      case VAL_KIND_INT:
      case VAL_KIND_FLOAT:
        $this->emit((string) $value->data);
        break;
        
      case VAL_KIND_STR:
        $this->emit_str_value($value->data);
        break;
        
      case VAL_KIND_BOOL:
        $this->emit_bool_value($value->data);
        break;
        
      case VAL_KIND_LIST:
        $this->emit_list_value($value->data);
        break;
        
      case VAL_KIND_TUPLE:
        $this->emit_tuple_value($value->data);
        break;
        
      case VAL_KIND_DICT:
        $this->emit_dict_Value($value->data);
        break;
        
      case VAL_KIND_NULL:
        $this->emit('null');
        break;
        
      case VAL_KIND_NEW:
      case VAL_KIND_SYMBOL:
        return false;
      
      default:
        assert(0);
    }
    
    return true;
  }
  
  /**
   * emits a string value
   *
   * @param  string $val
   * @return void
   */
  public function emit_str_value($val)
  {
    $buf = '"' . $this->format_str($val) . '"';
    
    if ($this->hstr) {
      $this->emit('\\');
      $this->emit(array_push($this->strs, $buf) - 1);
    } else
      $this->emit($buf);
  }
  
  /**
   * emits a boolean value
   *
   * @param  boolean $val
   * @return void
   */
  private function emit_bool_value($val) 
  {
    $this->emit($val ? 'true' : 'false');
  }
  
  /**
   * emits a list value
   *
   * @param  array $list
   * @return void
   */
  private function emit_list_value($list)
  {
    $this->emit('new \\List_(');
    
    if (!empty ($list)) {
      $this->emitln();
      $this->indent();
    
      foreach ($list as $idx => $item) {
        if ($idx > 0) $this->emitln(',');
        $this->emit_value($item);
      }
      
      $this->dedent();
      $this->emitln();
    }
    
    $this->emit(')');
  }
  
  /**
   * emits a tuple value
   *
   * @param  array $list
   * @return void
   */
  private function emit_tuple_value($list)
  {
    if (empty ($list)) {
      $this->emit('[]');
      return;
    }
    
    $this->emitln('[');
    $this->indent();
    
    foreach ($list as $idx => $item) {
      if ($idx > 0)
        $this->emitln(',');
      
      $this->emit_value($item);
    }
    
    $this->dedent();
    $this->emit(']');
  }
  
  /**
   * emits a list value
   *
   * @param  array $list
   * @return void
   */
  private function emit_dict_value($dict)
  {
    $this->emit('new \\Dict(');
    
    if (!empty ($dict)) {    
      $this->emitln('[');
      $this->indent();
      
      $idx = 0;
      foreach ($dict as $key => $val) {
        if ($idx++ > 0)
          $this->emitln(',');
        
        // PHP converts number-like keys to integers
        // ... and you can't do anything against it
        
        $this->emit_str_value((string)$key);
        $this->emit(' => ');
        $this->emit_value($val);
      }
      
      $this->dedent();
      $this->emit(']');
    }
    
    $this->emit(')');
  }
  
  /* ------------------------------------ */
  
  /**
   * emits the start (header) of a namespace
   *
   * @param  ModuleScope $mod
   */
  public function emit_ns_beg(ModuleScope $mod = null)
  {
    $this->emit('namespace ');
    
    if ($mod !== null && $mod->id !== null) {
      $this->emit(path_to_ns($mod->path()));
      $this->emit(' ');
    }
    
    $this->emitln('{');
    $this->indent();
  }
  
  /**
   * emits the end (footer) of a namespace
   *
   */
  public function emit_ns_end()
  {
    $this->dedent();
    $this->emitln('}');
  }
  
  /* ------------------------------------ */
  
  /**
   * emits a function-declaration
   *
   * @param  Node $node
   */
  public function emit_fn_decl($node)
  {
    $fsym = $node->symbol;
    
    if ($fsym->flags & SYM_FLAG_EXTERN)
      return;
    
    $this->emit('function ', $fsym->id);
    $this->emit_fn_params($node);
    $this->emit_fn_body($node);
  }
  
  /**
   * emits a function-expression
   *
   * @param  Node $node
   * @param  boolean  $decl  the function is actually a declaration
   */
  public function emit_fn_expr($node, $decl = false)
  {
    $fsym = $node->symbol;
    
    $this->emit('$', $fsym->id, ' = function');
    $this->emit_fn_params($node);
    $this->emit_fn_body($node, true, $decl);
  }
  
  /**
   * emits function-params
   *
   * @param  Node $node
   */
  public function emit_fn_params($node)
  {
    $fsym = $node->symbol;
    
    $this->emit('(');
          
    foreach ($fsym->params as $idx => $psym) {
      if ($idx > 0) $this->emit(', ');
      
      if ($psym->hint && !($psym->hint instanceof TypeId)) {
        $this->emit('\\', path_to_ns($psym->hint->symbol->path()));
        $this->emit(' ');
      }
      
      if ($psym->ref) $this->emit('&');
      if ($psym->rest) $this->emit('...');
      
      $this->emit('$', $psym->id);      
    }
      
    $this->emit(') ');
  }
  
  /**
   * emits function global-captures
   *
   * @param  Node $node
   */
  public function emit_fn_globals($node)
  {
    foreach ($node->scope->capt as $sym)
      if ($sym->scope->is_global())
        $this->emitln('global $', $sym->id, ';');
  }
  
  /**
   * emits function captures
   *
   * @param  Node $node
   */
  public function emit_fn_captures($node)
  {
    $capt = [];
    
    if ($node instanceof FnExpr || $node->nested)
      // capture self
      $capt[] = $node->symbol;
    
    foreach ($node->scope->capt as $csym)
      if (!$csym->scope->is_global())
        $capt[] = $csym;
    
    if (empty ($capt))
      return;
    
    $this->emit('use (');
      
    foreach ($capt as $idx => $csym) {
      if ($idx > 0) $this->emit(', ');
      $this->emit('&$', $csym->id);
    }
      
    $this->emit(') ');
  }
  
  /**
   * emits additional parameter type-checks
   *
   * @param  Node $node
   */
  public function emit_fn_checks($node)
  {
    static $ttos = [
      T_TINT => 'int',
      T_TBOOL => 'bool',
      T_TFLOAT => 'float',
      T_TSTRING => 'string'
    ];
    
    $fsym = $node->symbol;
    
    foreach ($fsym->params as $idx => $psym)
      if ($psym->hint && $psym->hint instanceof TypeId) {
        $id = $psym->id;
        $nr = '';
        $fn = $ttos[$psym->hint->type];
        
        if ($psym->rest) {
          $nr = '_T' . (self::$temp++);
          $id = '_T' . (self::$temp++);
          $this->emit('foreach ($', $psym->id, ' as $', $nr);
          $this->emitln(' => $', $id, ')');
          $this->indent();
        }
        
        if ($psym->ref) {
          $this->emitln('if (!is_', $fn, '($', $id, '))');
          $this->indent();
          $this->emit('throw new \\InvalidArgumentException(', "'");
          $this->emit($fsym->rid, '(): parameter #', $idx + 1, ' ');
          $this->emit('(`', $psym->rid, '`) - expected argument');
          
          // well, now we have argumentS
          if ($psym->rest) $this->emit('s');
          
          $this->emit(' of type ', $fn);
          
          // mark the argument as tuple
          if ($psym->rest) 
            $this->emit(' [...]');
          
          $this->emit(", ' . gettype($", $id, ") . ' given");
          
          // show offset of invalid tuple-value
          if ($psym->rest) 
            $this->emit(" at position ' . ($", $nr, ' + ', $idx + 1, ')');
          else
            $this->emit("'");
          
          $this->emitln(');');
          $this->dedent();
        } else
          $this->emitln('$', $id, ' = (', $fn, ') $', $id, ';');
          
        if ($psym->rest) {
          self::$temp -= 2;
          $this->dedent();
        } 
      }
  }
  
  /**
   * emits a function-body
   *
   * @param  Node $node
   * @param  boolean $expr  this body is part of a function-expression
   * @param  boolean $term  the function needs a terminator (semicolon)
   */
  public function emit_fn_body($node, $expr = false, $term = false)
  {
    if ($expr === true)
      $this->emit_fn_captures($node);
    
    $this->emitln('{');
    $this->indent();
    
    $this->emit_fn_globals($node);
    $this->emit_fn_checks($node);
    
    // visit block-body directly
    $this->nest++;
    $this->visit($node->body->body);
    $this->nest--;
    
    $this->dedent();
    $this->emit('}');
    
    if ($term === true)
      $this->emit(';');
    
    $this->emitln();
  }
  
  /* ------------------------------------ */
  
  /**
   * hoist dict expressions
   *
   * @param  Node $node
   * @param  string $temp
   * @return string
   */
  public function hoist_dict_expr($node, $temp = null)
  {
    if (!($node instanceof ObjLit))
      return null;
    
    $decr = false;
    
    if ($temp === null) {
      $temp = '_T' . (self::$temp++);
      $decr = true;
    }
    
    $this->emitln('$', $temp, ' = new \\Dict;');
    
    foreach ($node->pairs as $pair) {
      $hdct = null;
      
      if ($pair->arg instanceof ObjLit)
        // hoist value first
        $hdct = $this->hoist_dict_expr($pair->arg);
      elseif ($pair->arg instanceof CallExpr) {
        // hoist call
        $ctmp = '_T' . (self::$temp++);
        $this->visit_top_call_expr($pair->arg, $ctmp);
        $this->emitln(';');
        self::$temp--;
        $hdct = '$' . $ctmp;
      }
      
      $this->emit('$', $temp, '->');
      
      if ($pair->key instanceof ObjKey) {
        // computed
        $this->emit('{');
        $this->visit($pair->key->expr);
        $this->emit('}');
      } else
        $this->emit(ident_to_str($pair->key));
        
      $this->emit(' = ');
      
      if ($hdct !== null)
        $this->emit($hdct);
      else
        $this->visit($pair->arg);
      
      $this->emitln(';');
      
      if ($hdct !== null)
        $this->emitln('unset (', $hdct, ');');
    }
    
    if ($decr === true)
      self::$temp--;
    
    return '$' . $temp;
  }
  
  /**
   * hoist dict arguments
   *
   * @param  array $node
   * @return array  
   */
  public function hoist_dict_args($node)
  {
    if (!$node) return $node;
    
    $args = [];
    $tmpd = 0;
    
    foreach ($node as $arg) {
      // hoist obj-literal
      if ($arg instanceof ObjLit) {
        $arg = $this->hoist_dict_expr($arg);
        self::$temp++; // keep `temp` incremented for now
        $tmpd++;
        
      // hoist call
      } elseif ($arg instanceof CallExpr) {
        $temp = '_T' . (self::$temp++);
        $this->visit_top_call_expr($arg, $temp);
        $this->emitln(';');
        $arg = '$' . $temp;
        $tmpd++;
      }
      
      // else
      // don't touch $arg
      
      $args[] = $arg;
    }
    
    self::$temp -= $tmpd;
    return $args;
  }
  
  /* ------------------------------------ */
  
  /**
   * Visitor#visit_fn_args()
   *
   * @param  array $args
   */
  public function visit_fn_args($args) 
  {
    $this->emit('(');
    
    if (!empty($args)) {
      $len = count($args);
      foreach ($args as $idx => $arg) {
        if ($idx > 0) $this->emit(', ');
        
        // due to "hoist_dict_args()"
        if (is_string($arg))
          $this->emit($arg);
        
        elseif ($arg instanceof RestArg) {
          $this->emit('...');
          $this->visit($arg->expr);
        } 
        
        else
          $this->visit($arg);
      }
    }
    
    $this->emit(')');
  }
  
  /**
   * Visitor#visit_fn_params()
   *
   * @param  array $params
   */
  public function visit_fn_params($params) 
  {
    // handled by emit_fn_params()
  }
  
  /* ------------------------------------ */
  
  public function visit_unit($node) 
  {
    $this->emit_ns_beg();
    $this->visit($node->body);
    $this->emit_ns_end();
  }
  
  public function visit_module($node) 
  {
    $pmod = null;
    
    // close previous module
    if ($this->imod > 0)
      $pmod = array_pop($this->mods);
    
    $this->emit_ns_end();
    
    $this->imod++;
    
    $cmod = $node->scope;
    array_push($this->mods, $cmod);
    
    $this->emit_ns_beg($cmod);
    $this->visit($node->body);
    $this->emit_ns_end();
    
    $this->imod--;
    
    // re-open previous module
    if ($pmod) {
      array_push($this->mods, $pmod);
      $this->emit_ns_beg($pmod);
    } else
      $this->emit_ns_beg();
  }
  
  public function visit_content($node) 
  {
    $this->visit($node->body);  
  } 
  
  public function visit_block($node) 
  {
    $this->nest++;
    
    $this->emitln('{');
    $this->indent();
    $this->visit($node->body);
    $this->dedent();
    $this->emitln('}');
    
    // unset vars  
    $scope = $node->scope;
    if ($scope->count()) {
      $this->emit('unset (');
        
      foreach ($scope->iter() as $idx => $sym) {
        if ($idx > 0) $this->emit(', ');
        $this->emit('$', $sym->id);
      }
      
      $this->emit(')');
      $this->emitln(';');
    }
    
    $this->nest--;
  }
  
  public function visit_enum_decl($node) 
  {
    // TODO: implement enums
  }
  
  public function visit_class_decl($n) {}
  
  public function visit_nested_mods($node) 
  {
    // noop
  }
  
  public function visit_ctor_decl($n) {}
  public function visit_dtor_decl($n) {}
  public function visit_getter_decl($n) {}
  public function visit_setter_decl($n) {}
  public function visit_trait_decl($n) {}
  public function visit_iface_decl($n) {}
    
  public function visit_fn_decl($node) 
  {
    if ($node->nested)
      $this->emit_fn_expr($node, true);
    else
      $this->emit_fn_decl($node);
  }
  
  public function visit_var_decl($node) 
  {
    foreach ($node->vars as $var) {
      if (!$var->init) 
        // no declaration needed
        continue;
      
      $temp = $this->hoist_dict_expr($var->init);
      $this->emit('$', $var->symbol->id, ' = ');
      
      if ($temp !== null) {
        $this->emit($temp);
        $this->emitln(';');
        $this->emit('unset (', $temp, ')');
      } else
        $this->visit($var->init);
      
      $this->emitln(';');
    }
  }
  
  public function visit_use_decl($node) 
  {
    // noop  
  }
  
  public function visit_require_decl($node) 
  {
    $this->emit('require_once ');
    $this->emitqs($node->path); 
    $this->emitln(';');
  }
  
  public function visit_label_decl($node) 
  {
    $this->emitln(ident_to_str($node->id), ':');
    $this->visit($node->stmt);
  }
  
  public function visit_do_stmt($node) 
  {
    $this->emit('do ');
    $this->visit($node->stmt);
    $this->buff = rtrim($this->buff, "\n ");
    $this->emit(' while (');
    $this->visit($node->test);
    $this->emitln(');');  
  }
  
  public function visit_if_stmt($node) 
  {
    $this->emit('if (');
    $this->visit($node->test);
    $this->emit(') ');
    $this->visit($node->stmt);
    
    if ($node->elsifs) {
      foreach ($node->elsifs as $elsif) {
        $this->buff = rtrim($this->buff, "\n ");
        $this->emit(' elseif (');
        $this->visit($elsif->test);
        $this->emit(') ');
        $this->visit($elsif->stmt);   
      } 
    } 
    
    if ($node->els) {
      $this->buff = rtrim($this->buff, "\n ");
      $this->emit(' else ');
      $this->visit($node->els->stmt);
    }
  }
  
  public function visit_for_stmt($node) 
  {
    $this->emit('for (');
      
    if ($node->init) {
      $this->visit($node->init);
      $this->buff = rtrim($this->buff, "\n ");
      $this->emit(' ');
    } else
      $this->emit('; ');
    
    if ($node->test) {
      $this->visit($node->test);
      $this->buff = rtrim($this->buff, "\n ");
      $this->emit(' ');
    } else
      $this->emit('; ');
    
    $this->visit($node->each);
    $this->emit(') ');
    $this->visit($node->stmt);  
    
    if ($node->init instanceof VarDecl) {
      $this->emit('unset (');
      
      foreach ($node->init->vars as $idx => $var) {
        if ($idx > 0) $this->emit(', ');
        $this->emit('$', $var->symbol->id);
      }
      
      $this->emit(');');
    }
  }
  
  public function visit_for_in_stmt($node) 
  {
    $this->emit('foreach (');
    $this->visit($node->rhs);
    $this->emit(' as ');
    
    $key = $node->lhs->key;
    $arg = $node->lhs->arg;
    
    if ($key !== null)
      $this->emit('$', $key->symbol->id, ' => ');  
    
    $this->emit('$', $arg->symbol->id);
    $this->emit(') ');
    $this->visit($node->stmt);
    
    $this->emit('unset (');
    
    if ($key != null)
      $this->emit('$', $key->symbol->id, ', ');
    
    $this->emit('$', $arg->symbol->id);
    $this->emitln(');');
  }
  
  public function visit_try_stmt($node) 
  {
    // TODO: implement try-catch-finally
  }
  
  public function visit_php_stmt($node) 
  {
    $this->emitln('/* inline php {{ */');
    $this->indent();
    
    // TODO: resolve usage!
    $this->emit_str($node->code);
    
    $this->dedent();
    $this->emitln('/* inline php }} */');
  }
  
  public function visit_goto_stmt($node) 
  {
    $this->emitln('goto ', ident_to_str($node->id), ';');  
  }
  
  public function visit_test_stmt($node) 
  {
    // if INCLUDE_TESTS
    // ...
    // TODO: implement
  }
  
  public function visit_break_stmt($n) {}
  public function visit_continue_stmt($n) {}
  
  public function visit_print_stmt($node) 
  {
    $this->emit('echo ');
    
    foreach ($node->expr as $i => $expr) {
      if ($i > 0) $this->emit(', ');
      
      if ($expr instanceof StrLit)
        $this->emit_str($expr, false);
      else
        $this->visit($expr);
    }
    
    $this->emitln(', \\PHP_EOL;');
  }
  
  public function visit_throw_stmt($node) 
  {
    $this->emit('throw ');
    $this->visit($node->expr);
    $this->emitln(';');  
  }
  
  public function visit_while_stmt($node) 
  {
    $this->emit('while (');
    $this->visit($node->test);
    $this->emit(') ');
    $this->visit($node->stmt);   
  }
  
  public function visit_assert_stmt($node) 
  {
    $this->emit('\\assert(');
    $this->visit($node->expr);
    
    if ($node->message) {
      $this->emit(', ');
      $this->visit($node->message);
    }
    
    $this->emitln(');');  
  }
  
  public function visit_switch_stmt($node) 
  {
    $this->emit('switch (');
    $this->visit($node->test);
    $this->emitln(') {');
    $this->indent();
    
    foreach ($node->cases as $case) {
      $len = count($case->labels);
      foreach ($case->labels as $idx => $label) {
        if ($label->expr === null)
          $this->emit('default:');
        else {
          $this->emit('case ');
          $this->visit($label->expr);
          $this->emit(':');
        }
        
        if ($idx + 1 < $len)
          $this->emitln();
      }
      
      $this->indent();
      $this->visit($case->body);
      $this->dedent();
    }
    
    $this->dedent();
    $this->emitln('}');
  }
  
  public function visit_return_stmt($node) 
  {
    $this->emit('return');
    
    if ($node->expr) {
      $this->emit(' ');
      $this->visit($node->expr);
    }
    
    $this->emitln(';');
  }
  
  public function visit_expr_stmt($node) 
  {
    if ($node->expr)
      foreach ($node->expr as $expr) {
        /* specialized call */
        if ($expr instanceof CallExpr)
          $this->visit_top_call_expr($expr);
        
        /* specialized assign */
        elseif ($expr instanceof AssignExpr)
          $this->visit_top_assign_expr($expr);
        
        /* everything else */
        else
          $this->visit($expr);
        
        $this->emitln(';');
      }
    else
      $this->emitln(';');
  }
  
  /**
   * specialized version of Visitor#visit_call_expr()
   *
   * @param  Node $node
   * @param  string  $temp
   */
  public function visit_top_call_expr($node, $temp = null)
  {
    /* chained call */
    if ($node->callee instanceof CallExpr) {
      // this is a optimized form of what 
      // visit_call_expr() already does with chained calls
      
      $decr = $temp === null;
      $list = $this->collect_callees($node);
      $temp = $temp ?: '_T' . (self::$temp++);
      $init = array_pop($list);
      
      // special dict-argument-handler
      $args = $this->hoist_dict_args($init->args);
      
      // foo()() ->
      // $_T = foo();
      // $_T = $_T();
      // ...
      $this->emit('$', $temp, ' = ');
      $this->visit($init->callee);
      $this->visit_fn_args($args);
      
      $tmpd = [];
      foreach ($args as $arg)
        if (is_string($arg))
          $tmpd[] = $arg;
        
      while (!empty ($list)) {
        $this->emitln(';');
        $this->emit('$', $temp, ' = $', $temp);
        
        $call = array_pop($list);
        $args = $this->hoist_dict_args($call->args);
        $this->visit_fn_args($args);
        
        foreach ($args as $arg)
          if (is_string($arg))
            $tmpd[] = $arg;
      }
      
      if ($decr === true) {
        self::$temp--;
        $tmpd[] = '$' . $temp;
      }
      
      if (!empty ($tmpd)) {
        $this->emitln(';');
        $this->emit('unset (');
        foreach ($tmpd as $idx => $temp) {
          if ($idx > 0) $this->emit(', ');
          $this->emit($temp);
        }
        $this->emit(')');
      }
      
    /* normal call */
    } else {
      $args = $this->hoist_dict_args($node->args);
      
      if ($temp !== null)
        $this->emit('$', $temp, ' = ');
      
      $this->visit($node->callee);
      $this->visit_fn_args($args);
      
      $tmpd = [];
      foreach ($args as $arg)
        if (is_string($arg))
          $tmpd[] = $arg;
        
      if (!empty ($tmpd)) {
        $this->emitln(';');
        $this->emit('unset (');
        foreach ($tmpd as $idx => $temp) {
          if ($idx > 0) $this->emit(', ');
          $this->emit($temp);
        }
        $this->emit(')');
      }
    }
  }
  
  /**
   * specialized version of Visitor#visit_assign_expr()
   *
   * @param  Node $node
   */
  public function visit_top_assign_expr($node)
  {
    /* hoist dictionary literals */
    if ($node->right instanceof ObjLit) {
      $temp = $this->hoist_dict_expr($node->right);
      $this->visit($node->left);
      $this->emit_op($node->op);
      
      if ($temp !== null) {
        $this->emit($temp);
        $this->emitln(';');
        $this->emit('unset (', $temp, ')');
      } else
        $this->visit($node->right);
      
    /* call */
    } elseif ($node->right instanceof CallExpr) {
      // layout call
      if (($node->left instanceof Name ||
           $node->left instanceof Ident) &&
          $node->op->type === T_ASSIGN &&
          $node->left->symbol instanceof VarSymbol) {
        $temp = $node->left->symbol->id;
        $this->visit_top_call_expr($node->right, $temp);
        
      // hoist call
      } else {
        $temp = '_T' . (self::$temp++);
        $this->visit_top_call_expr($node->right, $temp);
        $this->visit($node->left);
        $this->emit_op($node->op);
        $this->emitln('$', $temp, ';');
        $this->emit('unset ($', $temp, ')');
        self::$temp--;
      }
      
    /* not special */ 
    } else
      $this->visit_assign_expr($node);
  }
  
  public function visit_paren_expr($node) 
  {
    $this->emit('(');
    $this->visit($node->expr);
    $this->emit(')');  
  }
  
  public function visit_tuple_expr($n) {}
  
  public function visit_fn_expr($node) 
  {
    $this->emit_fn_expr($node);
  }
  
  public function visit_bin_expr($node) 
  {
    if ($this->emit_value($node->value))
      return;
    
    $this->visit($node->left);
    $this->emit(' ');
    $this->emit($node->op->value);
    $this->emit(' ');
    $this->visit($node->right);    
  }
  
  public function visit_check_expr($node) 
  {
    if ($this->emit_value($node->value))
      return;
    
    $this->visit($node->left);
    $this->emit(' ');
    $this->emit($node->op->value);
    $this->emit(' ');
    $this->visit($node->right); 
  }
  
  public function visit_cast_expr($n) {}
  
  public function visit_update_expr($node) 
  {
    if ($node->prefix)
      $this->emit($node->op->value);
    
    $this->visit($node->expr);
    
    if (!$node->prefix)
      $this->emit($node->op->value);
  }
  
  public function visit_assign_expr($node) 
  {
    $this->visit($node->left);
    $this->emit(' ');
    $this->emit_op($node->op);
    $this->emit(' ');
    $this->visit($node->right);  
  }
  
  public function visit_member_expr($node) 
  {
    if ($this->emit_value($node->value))
      return;
    
    $paren = false;
    if ($node->object instanceof NewExpr) {
      $paren = true;
      $this->emit('(');
    }
    
    $this->visit($node->object);
    
    if ($paren)
      $this->emit(')');
    
    $this->emit('->');
    
    if ($node->computed)
      $this->emit('{'); 
    
    $this->visit($node->member);
    
    if ($node->computed)
      $this->emit('}');
  }
  
  public function visit_offset_expr($node) 
  {
    if ($this->emit_value($node->value))
      return;
    
    $this->visit($node->object);
    $this->emit('[');
    $this->visit($node->offset);
    $this->emit(']');
  }
  
  public function visit_cond_expr($node) 
  {
    if ($this->emit_value($node->value))
      return;
    
    $this->visit($node->test);
    $this->emit(' ? ');
    
    if ($node->then)
      $this->visit($node->then);
    
    $this->emit(' : ');
    $this->visit($node->els);
  }
  
  public function visit_call_expr($node) 
  {
    if ($node->callee instanceof CallExpr) {
      // foo()() is not possible in PHP
      // therefore we have to generate a workaround      
      
      $list = $this->collect_callees($node);
      $temp = '_T' . (self::$temp++);
      $init = array_pop($list);
      
      // foo()() ->
      // [
      //   0 => $_T = foo(), 
      //   0 => $_T = $_T() 
      // ][0]
      $this->emitln('[ /* chained call */');
      $this->indent();
      $this->emit('0 => ($', $temp, ' = ');
      
      $this->visit($init->callee);
      $this->visit_fn_args($init->args);
      
      while (!empty ($list)) {
        $this->emitln('),');
        $this->emit('0 => ($', $temp, ' = $', $temp);
        $this->visit_fn_args(array_pop($list)->args);
      }
      
      $this->emit(')');
      $this->dedent();
      $this->emit('][0]');
      
      self::$temp--;
    } else {
      $this->visit($node->callee);
      $this->visit_fn_args($node->args);
    }
  }
  
  public function visit_yield_expr($n) {}
  public function visit_unary_expr($n) {}
  public function visit_new_expr($n) {}
  public function visit_del_expr($n) {}
  
  public function visit_lnum_lit($node) 
  {
    $this->emit($node->data);  
  }
  
  public function visit_dnum_lit($node) 
  {
    $this->emit($node->data);  
  }
  
  public function visit_snum_lit($node) 
  {
    // TODO: implement snums
  }
  
  public function visit_regexp_lit($n) {}
  
  
  public function visit_arr_gen($n) {}
  
  public function visit_arr_lit($node) 
  {
    if ($this->emit_Value($node->value))
      return;
    
    $this->emit('new \\List_(');
    
    if (!empty ($node->items)) {    
    $this->emit('[');
    $this->tabs++;
    $this->emitln('');
    
    $len = count($node->items);
    foreach ($node->items as $idx => $item) {
      $this->visit($item);
      
      if ($idx + 1 < $len)
        $this->emitln(', ');
    }  
    
    $this->tabs--;
    $this->emitln('');
    $this->emit(']');
    }
    
    $this->emit(')');
  }
  
  public function visit_obj_lit($node) 
  {
    if ($this->emit_value($node->value))
      return;
    
    $this->emit('new \\Dict(');
    
    if (!empty ($node->pairs)) {
      $this->emitln('[');
      $this->indent();
      
      foreach ($node->pairs as $idx => $pair) {
        if ($idx > 0) $this->emitln(', ');
        if ($pair->key instanceof ObjKey) {
          $this->emit('(');
          $this->visit($pair->key->expr);
          $this->emit(')');
        } else
          $this->emitqs(ident_to_str($pair->key));
        
        $this->emit(' => ');
        $this->visit($pair->arg);
      }
      
      $this->dedent();
      $this->emit(']');
    }
    
    $this->emit(')');  
  }
  
  public function visit_name($node) 
  {
    $sym = $node->symbol;
    
    if ($sym instanceof VarSymbol ||
        ($sym instanceof FnSymbol && $sym->nested))
      $this->emit('$', $sym->id);
    else
      $this->emit('\\', path_to_ns($sym->path()));
  }
  
  public function visit_ident($node) 
  {
    $sym = $node->symbol;
    
    if ($sym instanceof VarSymbol ||
        ($sym instanceof FnSymbol && $sym->nested))
      $this->emit('$', $sym->id);
    else
      $this->emit('\\', path_to_ns($sym->path()));  
  }
  
  public function visit_this_expr($node) 
  {
    $this->emit('$this');
  }
  
  public function visit_super_expr($node) 
  {
    $this->emit('parent');  
  }
  
  public function visit_self_expr($node) 
  {
    $this->emit('self');  
  }
  
  public function visit_null_lit($node) 
  {
    $this->emit('null');  
  }
  
  public function visit_true_lit($node) 
  {
    $this->emit('true');  
  }
  
  public function visit_false_lit($node) 
  {
    $this->emit('false');  
  }
  
  public function visit_str_lit($node) 
  {
    $this->emit_str($node);
  }
  
  public function visit_kstr_lit($node) 
  {
    $this->emitqs($node->data);  
  }
  
  public function visit_type_id($node) 
  {
    // noop  
  }
  
  public function visit_engine_const($node) 
  {
    $this->emitqs($node->data);
  }
}
